#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]


use std::f64::consts::PI;
//use std::alloc::{alloc, dealloc, Layout};
extern crate libc;

pub fn get_doppler_shift(tle: (&str,&str),latitude: f64, longitude: f64, altitude: f64, time: i64, downlink_frequency: f64) -> f64 {
    let (tle_line_1, tle_line_2) = tle;


    unsafe {

        let orbital_elements = predict_parse_tle(tle_line_1.as_ptr() as *const i8, tle_line_2.as_ptr() as *const i8);

        let mut orbit = predict_position::default(); //independent of an observer
        let mut observation = predict_observation::default() ; //relative to an observer

        let pred_time = predict_to_julian(time);
        predict_orbit(orbital_elements, &mut orbit, pred_time);

        
        let observer = predict_create_observer("LA1K".as_ptr() as *const i8, latitude/180.0*PI, longitude/180.0*PI, altitude);
        predict_observe_orbit(observer, &orbit, &mut observation);


        let doppler_shift = predict_doppler_shift(&observation, downlink_frequency);

        libc::free((*orbital_elements).ephemeris_data as *mut ::std::os::raw::c_void);
        libc::free(orbital_elements as *mut libc::c_void);
        libc::free(observer as *mut libc::c_void);

        doppler_shift
    }
}






/* automatically generated by rust-bindgen 0.60.1 */

pub const _TIME_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 31;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __LONG_DOUBLE_USES_FLOAT128: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const _BITS_TIME_H: u32 = 1;
pub const _BITS_TYPES_H: u32 = 1;
pub const __TIMESIZE: u32 = 64;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const __clock_t_defined: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const __struct_tm_defined: u32 = 1;
pub const _STRUCT_TIMESPEC: u32 = 1;
pub const _BITS_ENDIAN_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __PDP_ENDIAN: u32 = 3412;
pub const _BITS_ENDIANNESS_H: u32 = 1;
pub const __BYTE_ORDER: u32 = 1234;
pub const __FLOAT_WORD_ORDER: u32 = 1234;
pub const __clockid_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const __itimerspec_defined: u32 = 1;
pub const _BITS_TYPES_LOCALE_T_H: u32 = 1;
pub const _BITS_TYPES___LOCALE_T_H: u32 = 1;
pub const __bool_true_false_are_defined: u32 = 1;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    fn test_field___val() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__fsid_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__fsid_t),
                "::",
                stringify!(__val)
            )
        );
    }
    test_field___val();
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type time_t = __time_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm {
    pub tm_sec: ::std::os::raw::c_int,
    pub tm_min: ::std::os::raw::c_int,
    pub tm_hour: ::std::os::raw::c_int,
    pub tm_mday: ::std::os::raw::c_int,
    pub tm_mon: ::std::os::raw::c_int,
    pub tm_year: ::std::os::raw::c_int,
    pub tm_wday: ::std::os::raw::c_int,
    pub tm_yday: ::std::os::raw::c_int,
    pub tm_isdst: ::std::os::raw::c_int,
    pub tm_gmtoff: ::std::os::raw::c_long,
    pub tm_zone: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_tm() {
    assert_eq!(
        ::std::mem::size_of::<tm>(),
        56usize,
        concat!("Size of: ", stringify!(tm))
    );
    assert_eq!(
        ::std::mem::align_of::<tm>(),
        8usize,
        concat!("Alignment of ", stringify!(tm))
    );
    fn test_field_tm_sec() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tm>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tm_sec) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(tm),
                "::",
                stringify!(tm_sec)
            )
        );
    }
    test_field_tm_sec();
    fn test_field_tm_min() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tm>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tm_min) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(tm),
                "::",
                stringify!(tm_min)
            )
        );
    }
    test_field_tm_min();
    fn test_field_tm_hour() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tm>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tm_hour) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(tm),
                "::",
                stringify!(tm_hour)
            )
        );
    }
    test_field_tm_hour();
    fn test_field_tm_mday() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tm>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tm_mday) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(tm),
                "::",
                stringify!(tm_mday)
            )
        );
    }
    test_field_tm_mday();
    fn test_field_tm_mon() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tm>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tm_mon) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(tm),
                "::",
                stringify!(tm_mon)
            )
        );
    }
    test_field_tm_mon();
    fn test_field_tm_year() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tm>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tm_year) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(tm),
                "::",
                stringify!(tm_year)
            )
        );
    }
    test_field_tm_year();
    fn test_field_tm_wday() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tm>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tm_wday) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(tm),
                "::",
                stringify!(tm_wday)
            )
        );
    }
    test_field_tm_wday();
    fn test_field_tm_yday() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tm>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tm_yday) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(tm),
                "::",
                stringify!(tm_yday)
            )
        );
    }
    test_field_tm_yday();
    fn test_field_tm_isdst() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tm>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tm_isdst) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(tm),
                "::",
                stringify!(tm_isdst)
            )
        );
    }
    test_field_tm_isdst();
    fn test_field_tm_gmtoff() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tm>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tm_gmtoff) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(tm),
                "::",
                stringify!(tm_gmtoff)
            )
        );
    }
    test_field_tm_gmtoff();
    fn test_field_tm_zone() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tm>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tm_zone) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(tm),
                "::",
                stringify!(tm_zone)
            )
        );
    }
    test_field_tm_zone();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    fn test_field_tv_sec() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<timespec>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(timespec),
                "::",
                stringify!(tv_sec)
            )
        );
    }
    test_field_tv_sec();
    fn test_field_tv_nsec() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<timespec>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tv_nsec) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(timespec),
                "::",
                stringify!(tv_nsec)
            )
        );
    }
    test_field_tv_nsec();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
#[test]
fn bindgen_test_layout_itimerspec() {
    assert_eq!(
        ::std::mem::size_of::<itimerspec>(),
        32usize,
        concat!("Size of: ", stringify!(itimerspec))
    );
    assert_eq!(
        ::std::mem::align_of::<itimerspec>(),
        8usize,
        concat!("Alignment of ", stringify!(itimerspec))
    );
    fn test_field_it_interval() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<itimerspec>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).it_interval) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(itimerspec),
                "::",
                stringify!(it_interval)
            )
        );
    }
    test_field_it_interval();
    fn test_field_it_value() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<itimerspec>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).it_value) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(itimerspec),
                "::",
                stringify!(it_value)
            )
        );
    }
    test_field_it_value();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigevent {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const ::std::os::raw::c_ushort,
    pub __ctype_tolower: *const ::std::os::raw::c_int,
    pub __ctype_toupper: *const ::std::os::raw::c_int,
    pub __names: [*const ::std::os::raw::c_char; 13usize],
}
#[test]
fn bindgen_test_layout___locale_struct() {
    assert_eq!(
        ::std::mem::size_of::<__locale_struct>(),
        232usize,
        concat!("Size of: ", stringify!(__locale_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<__locale_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(__locale_struct))
    );
    fn test_field___locales() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__locale_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__locales) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__locale_struct),
                "::",
                stringify!(__locales)
            )
        );
    }
    test_field___locales();
    fn test_field___ctype_b() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__locale_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__ctype_b) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(__locale_struct),
                "::",
                stringify!(__ctype_b)
            )
        );
    }
    test_field___ctype_b();
    fn test_field___ctype_tolower() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__locale_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__ctype_tolower) as usize - ptr as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(__locale_struct),
                "::",
                stringify!(__ctype_tolower)
            )
        );
    }
    test_field___ctype_tolower();
    fn test_field___ctype_toupper() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__locale_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__ctype_toupper) as usize - ptr as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(__locale_struct),
                "::",
                stringify!(__ctype_toupper)
            )
        );
    }
    test_field___ctype_toupper();
    fn test_field___names() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__locale_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__names) as usize - ptr as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(__locale_struct),
                "::",
                stringify!(__names)
            )
        );
    }
    test_field___names();
}
pub type __locale_t = *mut __locale_struct;
#[doc = " The representation of time used by libpredict: The number of days since 31Dec79 00:00:00 UTC."]
pub type predict_julian_date_t = f64;
extern "C" {
    #[doc = " Convert time_t in UTC to Julian date in UTC."]
    #[doc = ""]
    #[doc = " \\param time Time in UTC"]
    #[doc = " \\return Julian day in UTC"]
    pub fn predict_to_julian(time: time_t) -> predict_julian_date_t;
}
#[doc = " Simplified perturbation models used in modeling the satellite orbits."]
pub type predict_ephemeris = ::std::os::raw::c_uint;
#[doc = " Container for processed TLE data from TLE strings."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct predict_orbital_elements_t {
    #[doc = "Satellite number (line 1, field 2)"]
    pub satellite_number: ::std::os::raw::c_int,
    #[doc = "Element number (line 1, field 13)"]
    pub element_number: ::std::os::raw::c_long,
    #[doc = "International designator (line 1, fields 4, 5, 6)"]
    pub designator: [::std::os::raw::c_char; 10usize],
    #[doc = "Epoch year (last two digits) (line 1, field 7)"]
    pub epoch_year: ::std::os::raw::c_int,
    #[doc = "Epoch day (day of year and fractional portion of day, line 1, field 8)"]
    pub epoch_day: f64,
    #[doc = "Inclination (line 2, field 3)"]
    pub inclination: f64,
    #[doc = "Right Ascension of the Ascending Node [Degrees] (line 2, field 4)"]
    pub right_ascension: f64,
    #[doc = "Eccentricity (line 2, field 5)"]
    pub eccentricity: f64,
    #[doc = "Argument of Perigee [Degrees] (line 2, field 6)"]
    pub argument_of_perigee: f64,
    #[doc = "Mean Anomaly [Degrees] (line 2, field 7)"]
    pub mean_anomaly: f64,
    #[doc = "Mean Motion [Revs per day] (line 2, field 8)"]
    pub mean_motion: f64,
    #[doc = "First Time Derivative of the Mean Motion divided by two (line 1, field 9)"]
    pub derivative_mean_motion: f64,
    #[doc = "Second Time Derivative of Mean Motion divided by six (line 1, field 10)"]
    pub second_derivative_mean_motion: f64,
    #[doc = "BSTAR drag term (decimal point assumed, line 1, field 11)"]
    pub bstar_drag_term: f64,
    #[doc = "Number of revolutions around Earth at epoch (line 2, field 9)"]
    pub revolutions_at_epoch: ::std::os::raw::c_int,
    #[doc = "Which perturbation model to use"]
    pub ephemeris: predict_ephemeris,
    #[doc = "Ephemeris data structure pointer"]
    pub ephemeris_data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_predict_orbital_elements_t() {
    assert_eq!(
        ::std::mem::size_of::<predict_orbital_elements_t>(),
        128usize,
        concat!("Size of: ", stringify!(predict_orbital_elements_t))
    );
    assert_eq!(
        ::std::mem::align_of::<predict_orbital_elements_t>(),
        8usize,
        concat!("Alignment of ", stringify!(predict_orbital_elements_t))
    );
    fn test_field_satellite_number() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<predict_orbital_elements_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).satellite_number) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(predict_orbital_elements_t),
                "::",
                stringify!(satellite_number)
            )
        );
    }
    test_field_satellite_number();
    fn test_field_element_number() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<predict_orbital_elements_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).element_number) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(predict_orbital_elements_t),
                "::",
                stringify!(element_number)
            )
        );
    }
    test_field_element_number();
    fn test_field_designator() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<predict_orbital_elements_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).designator) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(predict_orbital_elements_t),
                "::",
                stringify!(designator)
            )
        );
    }
    test_field_designator();
    fn test_field_epoch_year() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<predict_orbital_elements_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).epoch_year) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(predict_orbital_elements_t),
                "::",
                stringify!(epoch_year)
            )
        );
    }
    test_field_epoch_year();
    fn test_field_epoch_day() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<predict_orbital_elements_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).epoch_day) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(predict_orbital_elements_t),
                "::",
                stringify!(epoch_day)
            )
        );
    }
    test_field_epoch_day();
    fn test_field_inclination() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<predict_orbital_elements_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).inclination) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(predict_orbital_elements_t),
                "::",
                stringify!(inclination)
            )
        );
    }
    test_field_inclination();
    fn test_field_right_ascension() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<predict_orbital_elements_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).right_ascension) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(predict_orbital_elements_t),
                "::",
                stringify!(right_ascension)
            )
        );
    }
    test_field_right_ascension();
    fn test_field_eccentricity() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<predict_orbital_elements_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).eccentricity) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(predict_orbital_elements_t),
                "::",
                stringify!(eccentricity)
            )
        );
    }
    test_field_eccentricity();
    fn test_field_argument_of_perigee() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<predict_orbital_elements_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).argument_of_perigee) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(predict_orbital_elements_t),
                "::",
                stringify!(argument_of_perigee)
            )
        );
    }
    test_field_argument_of_perigee();
    fn test_field_mean_anomaly() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<predict_orbital_elements_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mean_anomaly) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(predict_orbital_elements_t),
                "::",
                stringify!(mean_anomaly)
            )
        );
    }
    test_field_mean_anomaly();
    fn test_field_mean_motion() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<predict_orbital_elements_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mean_motion) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(predict_orbital_elements_t),
                "::",
                stringify!(mean_motion)
            )
        );
    }
    test_field_mean_motion();
    fn test_field_derivative_mean_motion() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<predict_orbital_elements_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).derivative_mean_motion) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(predict_orbital_elements_t),
                "::",
                stringify!(derivative_mean_motion)
            )
        );
    }
    test_field_derivative_mean_motion();
    fn test_field_second_derivative_mean_motion() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<predict_orbital_elements_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).second_derivative_mean_motion) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(predict_orbital_elements_t),
                "::",
                stringify!(second_derivative_mean_motion)
            )
        );
    }
    test_field_second_derivative_mean_motion();
    fn test_field_bstar_drag_term() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<predict_orbital_elements_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bstar_drag_term) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(predict_orbital_elements_t),
                "::",
                stringify!(bstar_drag_term)
            )
        );
    }
    test_field_bstar_drag_term();
    fn test_field_revolutions_at_epoch() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<predict_orbital_elements_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).revolutions_at_epoch) as usize - ptr as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(predict_orbital_elements_t),
                "::",
                stringify!(revolutions_at_epoch)
            )
        );
    }
    test_field_revolutions_at_epoch();
    fn test_field_ephemeris() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<predict_orbital_elements_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ephemeris) as usize - ptr as usize
            },
            116usize,
            concat!(
                "Offset of field: ",
                stringify!(predict_orbital_elements_t),
                "::",
                stringify!(ephemeris)
            )
        );
    }
    test_field_ephemeris();
    fn test_field_ephemeris_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<predict_orbital_elements_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ephemeris_data) as usize - ptr as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(predict_orbital_elements_t),
                "::",
                stringify!(ephemeris_data)
            )
        );
    }
    test_field_ephemeris_data();
}
extern "C" {
    #[doc = " Create predict_orbital_elements_t from TLE strings."]
    #[doc = ""]
    #[doc = " \\param tle_line_1 First line of NORAD two-line element set string"]
    #[doc = " \\param tle_line_2 Second line of NORAD two-line element set string"]
    #[doc = " \\return Processed TLE parameters"]
    #[doc = " \\copyright GPLv2+"]
    pub fn predict_parse_tle(
        tle_line_1: *const ::std::os::raw::c_char,
        tle_line_2: *const ::std::os::raw::c_char,
    ) -> *mut predict_orbital_elements_t;
}
#[doc = " Predicted orbital values for satellite at a given time."]
#[repr(C)]
#[derive(Default, Debug, Copy, Clone)]
pub struct predict_position {
    #[doc = "Timestamp for last call to orbit_predict"]
    pub time: predict_julian_date_t,
    #[doc = "Whether the orbit has decayed"]
    pub decayed: bool,
    #[doc = "ECI position in km"]
    pub position: [f64; 3usize],
    #[doc = "ECI velocity in km/s"]
    pub velocity: [f64; 3usize],
    #[doc = "Latitude in radians, northing/easting"]
    pub latitude: f64,
    #[doc = "Longitude in radians, northing/easting"]
    pub longitude: f64,
    #[doc = "Altitude in km"]
    pub altitude: f64,
    #[doc = "Footprint diameter in km"]
    pub footprint: f64,
    #[doc = "Whether satellite is eclipsed by the earth"]
    pub eclipsed: ::std::os::raw::c_int,
    #[doc = "Eclipse depth"]
    pub eclipse_depth: f64,
    #[doc = "Orbital phase (mean anomaly)"]
    pub phase: f64,
    #[doc = "The current number of revolutions around Earth"]
    pub revolutions: ::std::os::raw::c_long,
    #[doc = "Current inclination (from xinck within sgp4/sdp4)"]
    pub inclination: f64,
    #[doc = "Current right ascension of the ascending node (from xnodek within sgp4/sdp4)"]
    pub right_ascension: f64,
    #[doc = "Current argument of perigee (from omgadf within sgp4/sdp4)"]
    pub argument_of_perigee: f64,
}
#[test]
fn bindgen_test_layout_predict_position() {
    assert_eq!(
        ::std::mem::size_of::<predict_position>(),
        152usize,
        concat!("Size of: ", stringify!(predict_position))
    );
    assert_eq!(
        ::std::mem::align_of::<predict_position>(),
        8usize,
        concat!("Alignment of ", stringify!(predict_position))
    );
    fn test_field_time() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<predict_position>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).time) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(predict_position),
                "::",
                stringify!(time)
            )
        );
    }
    test_field_time();
    fn test_field_decayed() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<predict_position>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).decayed) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(predict_position),
                "::",
                stringify!(decayed)
            )
        );
    }
    test_field_decayed();
    fn test_field_position() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<predict_position>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).position) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(predict_position),
                "::",
                stringify!(position)
            )
        );
    }
    test_field_position();
    fn test_field_velocity() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<predict_position>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).velocity) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(predict_position),
                "::",
                stringify!(velocity)
            )
        );
    }
    test_field_velocity();
    fn test_field_latitude() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<predict_position>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).latitude) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(predict_position),
                "::",
                stringify!(latitude)
            )
        );
    }
    test_field_latitude();
    fn test_field_longitude() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<predict_position>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).longitude) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(predict_position),
                "::",
                stringify!(longitude)
            )
        );
    }
    test_field_longitude();
    fn test_field_altitude() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<predict_position>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).altitude) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(predict_position),
                "::",
                stringify!(altitude)
            )
        );
    }
    test_field_altitude();
    fn test_field_footprint() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<predict_position>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).footprint) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(predict_position),
                "::",
                stringify!(footprint)
            )
        );
    }
    test_field_footprint();
    fn test_field_eclipsed() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<predict_position>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).eclipsed) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(predict_position),
                "::",
                stringify!(eclipsed)
            )
        );
    }
    test_field_eclipsed();
    fn test_field_eclipse_depth() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<predict_position>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).eclipse_depth) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(predict_position),
                "::",
                stringify!(eclipse_depth)
            )
        );
    }
    test_field_eclipse_depth();
    fn test_field_phase() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<predict_position>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).phase) as usize - ptr as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(predict_position),
                "::",
                stringify!(phase)
            )
        );
    }
    test_field_phase();
    fn test_field_revolutions() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<predict_position>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).revolutions) as usize - ptr as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(predict_position),
                "::",
                stringify!(revolutions)
            )
        );
    }
    test_field_revolutions();
    fn test_field_inclination() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<predict_position>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).inclination) as usize - ptr as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(predict_position),
                "::",
                stringify!(inclination)
            )
        );
    }
    test_field_inclination();
    fn test_field_right_ascension() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<predict_position>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).right_ascension) as usize - ptr as usize
            },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(predict_position),
                "::",
                stringify!(right_ascension)
            )
        );
    }
    test_field_right_ascension();
    fn test_field_argument_of_perigee() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<predict_position>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).argument_of_perigee) as usize - ptr as usize
            },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(predict_position),
                "::",
                stringify!(argument_of_perigee)
            )
        );
    }
    test_field_argument_of_perigee();
}
extern "C" {
    #[doc = " Main prediction function. Predict satellite orbit at given time."]
    #[doc = " \\param orbital_elements Orbital elements"]
    #[doc = " \\param x Predicted orbit"]
    #[doc = " \\param time Julian day in UTC"]
    #[doc = " \\return 0 if everything went fine"]
    #[doc = " \\copyright GPLv2+"]
    pub fn predict_orbit(
        orbital_elements: *const predict_orbital_elements_t,
        x: *mut predict_position,
        time: predict_julian_date_t,
    ) -> ::std::os::raw::c_int;
}
#[doc = " Observation point/ground station (QTH)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct predict_observer_t {
    #[doc = "Observatory name"]
    pub name: [::std::os::raw::c_char; 128usize],
    #[doc = "Latitude (WGS84, radians)"]
    pub latitude: f64,
    #[doc = "Longitude (WGS84, radians)"]
    pub longitude: f64,
    #[doc = "Altitude (WGS84, meters)"]
    pub altitude: f64,
}
#[test]
fn bindgen_test_layout_predict_observer_t() {
    assert_eq!(
        ::std::mem::size_of::<predict_observer_t>(),
        152usize,
        concat!("Size of: ", stringify!(predict_observer_t))
    );
    assert_eq!(
        ::std::mem::align_of::<predict_observer_t>(),
        8usize,
        concat!("Alignment of ", stringify!(predict_observer_t))
    );
    fn test_field_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<predict_observer_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(predict_observer_t),
                "::",
                stringify!(name)
            )
        );
    }
    test_field_name();
    fn test_field_latitude() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<predict_observer_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).latitude) as usize - ptr as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(predict_observer_t),
                "::",
                stringify!(latitude)
            )
        );
    }
    test_field_latitude();
    fn test_field_longitude() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<predict_observer_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).longitude) as usize - ptr as usize
            },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(predict_observer_t),
                "::",
                stringify!(longitude)
            )
        );
    }
    test_field_longitude();
    fn test_field_altitude() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<predict_observer_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).altitude) as usize - ptr as usize
            },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(predict_observer_t),
                "::",
                stringify!(altitude)
            )
        );
    }
    test_field_altitude();
}
#[doc = " Data relevant for a relative observation of an orbit or similar with respect to an observation point."]
#[repr(C)]
#[derive(Default, Debug, Copy, Clone)]
pub struct predict_observation {
    #[doc = "UTC time"]
    pub time: predict_julian_date_t,
    #[doc = "Azimuth angle (rad)"]
    pub azimuth: f64,
    #[doc = "Azimuth angle rate (rad/s)"]
    pub azimuth_rate: f64,
    #[doc = "Elevation angle (rad)"]
    pub elevation: f64,
    #[doc = "Elevation angle rate (rad/s)"]
    pub elevation_rate: f64,
    #[doc = "Range (km)"]
    pub range: f64,
    #[doc = "Range vector"]
    pub range_x: f64,
    #[doc = "Range vector"]
    pub range_y: f64,
    #[doc = "Range vector"]
    pub range_z: f64,
    #[doc = "Range velocity (km/s)"]
    pub range_rate: f64,
    #[doc = "Visibility status, whether satellite can be seen by optical means."]
    #[doc = "The satellite is defined to be visible if:"]
    pub visible: bool,
}
#[test]
fn bindgen_test_layout_predict_observation() {
    assert_eq!(
        ::std::mem::size_of::<predict_observation>(),
        88usize,
        concat!("Size of: ", stringify!(predict_observation))
    );
    assert_eq!(
        ::std::mem::align_of::<predict_observation>(),
        8usize,
        concat!("Alignment of ", stringify!(predict_observation))
    );
    fn test_field_time() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<predict_observation>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).time) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(predict_observation),
                "::",
                stringify!(time)
            )
        );
    }
    test_field_time();
    fn test_field_azimuth() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<predict_observation>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).azimuth) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(predict_observation),
                "::",
                stringify!(azimuth)
            )
        );
    }
    test_field_azimuth();
    fn test_field_azimuth_rate() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<predict_observation>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).azimuth_rate) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(predict_observation),
                "::",
                stringify!(azimuth_rate)
            )
        );
    }
    test_field_azimuth_rate();
    fn test_field_elevation() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<predict_observation>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).elevation) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(predict_observation),
                "::",
                stringify!(elevation)
            )
        );
    }
    test_field_elevation();
    fn test_field_elevation_rate() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<predict_observation>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).elevation_rate) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(predict_observation),
                "::",
                stringify!(elevation_rate)
            )
        );
    }
    test_field_elevation_rate();
    fn test_field_range() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<predict_observation>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).range) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(predict_observation),
                "::",
                stringify!(range)
            )
        );
    }
    test_field_range();
    fn test_field_range_x() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<predict_observation>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).range_x) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(predict_observation),
                "::",
                stringify!(range_x)
            )
        );
    }
    test_field_range_x();
    fn test_field_range_y() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<predict_observation>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).range_y) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(predict_observation),
                "::",
                stringify!(range_y)
            )
        );
    }
    test_field_range_y();
    fn test_field_range_z() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<predict_observation>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).range_z) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(predict_observation),
                "::",
                stringify!(range_z)
            )
        );
    }
    test_field_range_z();
    fn test_field_range_rate() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<predict_observation>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).range_rate) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(predict_observation),
                "::",
                stringify!(range_rate)
            )
        );
    }
    test_field_range_rate();
    fn test_field_visible() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<predict_observation>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).visible) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(predict_observation),
                "::",
                stringify!(visible)
            )
        );
    }
    test_field_visible();
}
extern "C" {
    #[doc = " Create observation point (QTH)."]
    #[doc = ""]
    #[doc = " \\param name Name of observation point"]
    #[doc = " \\param lat Latitude in radians (easting/northing)"]
    #[doc = " \\param lon Longitude in radians (easting/northing)"]
    #[doc = " \\param alt Altitude in meters"]
    #[doc = " \\return Allocated observation point"]
    pub fn predict_create_observer(
        name: *const ::std::os::raw::c_char,
        lat: f64,
        lon: f64,
        alt: f64,
    ) -> *mut predict_observer_t;
}
extern "C" {
    #[doc = " Find relative position of satellite with respect to an observer. Calculates range, azimuth, elevation and relative velocity."]
    #[doc = ""]
    #[doc = " \\param observer Point of observation"]
    #[doc = " \\param orbit Satellite orbit"]
    #[doc = " \\param obs Return of object for position of the satellite relative to the observer."]
    #[doc = " \\copyright GPLv2+"]
    pub fn predict_observe_orbit(
        observer: *const predict_observer_t,
        orbit: *const predict_position,
        obs: *mut predict_observation,
    );
}
extern "C" {
    #[doc = " Calculate doppler shift of a given downlink frequency with respect to an observer."]
    #[doc = ""]
    #[doc = " \\param observation Observation of a satellite orbit"]
    #[doc = " \\param downlink_frequency Downlink frequency of the satellite"]
    #[doc = " \\return The frequency difference from the original frequency"]
    #[doc = " \\copyright GPLv2+"]
    pub fn predict_doppler_shift(
        observation: *const predict_observation,
        downlink_frequency: f64,
    ) -> f64;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_data {
    pub _address: u8,
}

